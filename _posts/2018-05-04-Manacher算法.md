---
layout: post
title:  Manacher算法
date:   2018-05-04
categories: DP
tags: [blog]  
summary: Manacher算法
image: /image/begin again.jpg
---
有两类关于字符串的问题是在笔试里面经常会考到的：1.求一个字符串的最长回文子串(Longest Palindromic Substring);2.求一个字符串的最长回文子序列(Longest Palindromic Subsequence),回文的性质不必多说，这里要说的是子串和子序列的区别，子串是连续的不间断的，子序列可以是中断的，比如针对字符串aaaba,最长回文子串是aba，而最长回文子序列则是aaaa,求最长回文子序列的通用做法是反序字符串，求正序与反序的最长公共子序列(LCS)即可。

而对于第一类问题，则需要用到经典的Manacher算法了，这两天一直在看这个算法，所以感觉想写一点来帮自己梳理一下。这个算法一开始有个神奇的做法：为了统一奇数位字符串与偶数位字符串，一开始在原始字符串的间隔位上插入原字符串里面没有的符号，比如原始字符串是aaa，那么插入"#"，就变成"#a#a#a#"，这样就统一成了奇数位的字符串，在实际应用中，为了不越位，还在起始点和结束点插上一些符号，比如最后待处理的字符串变成了"@#a#a#a#$"

为了解决最长回文子串的问题，我们需要记录以处理后的字符串的每一位为中心所能形成的回文子串的半径（有了这个半径就可以计算出整个回文子串了），这个半径可以是以字符串本身来计算，比如#本身也可以算作一个回文串，这个半径是1，也可以不以字符串本身计算，比如#a#，如果不把a算在内，回文的半径是1，所以为了计算出最长的这个半径，要遍历整个字符串，所以要设置一个遍历的数组，用来记录字符串的每一位为中心所能形成的回文子串的半径。这个数组设为P，每个元素对应的即是P[i]了。

为了计算P[i],这里是要用到动态规划算法的，尽可能地利用到遍历到第i位前的信息，为的是减少时间复杂度，所以要设置两个辅助变量，一个是center，记录的是遍历到第i位前，所出现的最长回文子串的中心，以及right，遍历到第i位前，所出现的以center为中心的最长回文子串的右边界。

整个算法的程序如下：(以python为例，以输入字符串为aaa为例)

    def manachers(S):
        A = '@#' + '#'.join(S) + '#$'
        P = [0] * len(A)
        center = right = 0
        for i in range(1, len(A) - 1):                   
            if i < right:                                 #负责提速
                P[i] = min(right - i, P[2 * center - i])
            while A[i + P[i] + 1] == A[i - P[i] - 1]:     #负责更新半径
                P[i] += 1
            if i + Z[i] > right:                          #负责更新center，right
                center, right = i, i + P[i]

假设从第一位有效的开始遍历，即#，在计算回文半径时不把自身算在内，那么一开始的半径是0，右边界就是自身，通过
    while A[i + Z[i] + 1] == A[i - Z[i] - 1]:     #负责更新半径
        Z[i] += 1

来检查是不是存在回文半径不为0的情况

当右边界没有超过当前遍历到的i的时候，说明上一次查询到的回文串半径没有超过当前的i，为了确定当前i对应的回文半径，还只能通过while部分的语句来判断，而当右边界超过了当前遍历到的i的时候，说明上一次查询的回文串半径已经超过当前的位置(center+P(center)=right>i),则可以利用i关于center的对称点j来加速查找：

![p1.png](/image/p1.png)

假如j点的回文半径没有超过当前最大的回文半径，那么P[i]=P[j], j=center-(i-center)=2*center-i

![p2.png](/image/p2.png)

假如j点的回文半径超过了当前最大的回文半径，那么P[i]=right-i,否则当前最大回文半径不成立

所以要取P[j]与right-i的最小值来求得当前的P[i]

这是默认P[i]小于当前最大回文半径的情况，至于要检验P[i]是否可以更大，就要靠while语句来检验了




