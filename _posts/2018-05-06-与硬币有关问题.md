---
layout: post
title:  与硬币问题有关的两个问题
date:   2018-05-06
categories: DP
tags: [blog]  
summary: 01背包问题
image: /image/begin again.jpg
---
今天做了一个01背包问题的变式问题：

给定一个有n个正整数的数组A和一个整数sum,求选择数组A中部分数字和为sum的方案数。当两种选取方案有一个数字的下标不一样,我们就认为是不同的组成方案。

输入描述:

    输入为两行:
    第一行为两个正整数n(1 ≤ n ≤ 1000)，sum(1 ≤ sum ≤ 1000)
    第二行为n个正整数A[i](32位整数)，以空格隔开。

输出描述:

    输出所求的方案数

示例：

    5 15 5 5 10 2 3(输入)
    4(输出)

代码如下：

    n_sum0=list(raw_input().split(' '))
    n=int(n_sum0[0])
    sum0=int(n_sum0[1])
    array_input=n_sum0[2:len(n_sum0)]
    array=[]
    for i in range(len(array_input)):
        array.append(int(array_input[i]))
    dp=[[0 for column in range (sum0+1)] for row in range(n)]
    for i in range(n):
        dp[i][0]=1
    for j in range(1,sum0+1):
        if j==array[0]:
            dp[0][j]=1
    for i in range(1,n):
        for j in range(1,sum0+1):
            if j>=array[i]:
                dp[i][j]=dp[i-1][j]+dp[i-1][j-array[i]]
            else:
                dp[i][j]=dp[i-1][j]
    print dp[n-1][sum0]

与之前的牛牛分硬币有些不同的是，初始化dp矩阵第一行是等于第0个数组元素才为1，表明这个元素只能选一次，矩阵的第0列还是为1，表明要凑的数为0时，数组里的元素都不能选，也是1种选法。而dp状态转移矩阵也跟之前的有些区别，dp[i-1][j-array[i]]表明是选了这个数是唯一的。

以及之前做的头条笔试的另一个混合型背包问题：

![toutiao1.png](/image/toutiao1.png)
![toutiao2.png](/image/toutiao2.png)
![toutiao3.png](/image/toutiao3.png)

代码如下：

    array1_input=list(raw_input().split(' '))
    array2_input=list(raw_input().split(' '))
    array3_input=list(raw_input().split(' '))
    coin1=int(array1_input[0])
    coin2=int(array1_input[1])
    num=int(array1_input[2])
    array=[]
    for i in range(len(array2_input)):
        array.append(int(array2_input[i]))
    for j in range(len(array3_input)):
        array.append(int(array3_input[j]))
    dp=[[0 for column in range (num+1)] for row in range(len(array))]
    for i in range(len(array)):
        dp[i][0]=1
    for j in range(1,num+1):
        if j%array[0]==0:
            dp[0][j]=1
    for i in range(1,len(array)):
        for j in range(1,num+1):
            if i<=len(array2_input)-1:                       #这是可以多次取的硬币
                if j>=array[i]:
                    dp[i][j]=dp[i-1][j]+dp[i][j-array[i]]
                else:
                    dp[i][j]=dp[i-1][j]
            else:
                if j>=array[i]:
                    dp[i][j]=dp[i-1][j]+dp[i-1][j-array[i]]  #这是只能取一次的硬币
                else:
                    dp[i][j]=dp[i-1][j]
    print dp[len(array)-1][num]

其实是个组合问题，前半部分是多重背包问题，后半部分是01背包问题，状态转移方程由于两种硬币的取法不一样所以有点区别，所以只要分段解决就可以了。

